import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import (roc_auc_score, accuracy_score, recall_score, 
                           precision_score, confusion_matrix, roc_curve)
from sklearn.calibration import calibration_curve
import shap
from lifelines import KaplanMeierFitter
from lifelines.statistics import logrank_test
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ModelEvaluator:
    def __init__(self, model, feature_names):
        self.model = model
        self.feature_names = feature_names
        
    def calculate_metrics(self, y_true, y_pred_proba, threshold=0.5):
        """
        Calculate comprehensive evaluation metrics
        """
        y_pred = (y_pred_proba >= threshold).astype(int)
        
        metrics = {
            'auc': roc_auc_score(y_true, y_pred_proba),
            'accuracy': accuracy_score(y_true, y_pred),
            'sensitivity': recall_score(y_true, y_pred),
            'specificity': recall_score(y_true, y_pred, pos_label=0),
            'precision': precision_score(y_true, y_pred),
            'npv': self.calculate_npv(y_true, y_pred)
        }
        
        # Calculate PPV and NPV
        tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
        metrics['ppv'] = tp / (tp + fp) if (tp + fp) > 0 else 0
        metrics['npv'] = tn / (tn + fn) if (tn + fn) > 0 else 0
        
        return metrics
    
    def calculate_npv(self, y_true, y_pred):
        """Calculate Negative Predictive Value"""
        tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
        return tn / (tn + fn) if (tn + fn) > 0 else 0
    
    def find_optimal_cutoff(self, y_true, y_pred_proba):
        """
        Find optimal cutoff using Youden's index
        """
        fpr, tpr, thresholds = roc_curve(y_true, y_pred_proba)
        youden_index = tpr - fpr
        optimal_idx = np.argmax(youden_index)
        optimal_threshold = thresholds[optimal_idx]
        
        return optimal_threshold, youden_index[optimal_idx]
    
    def plot_roc_curve(self, y_true, y_pred_proba, dataset_name, save_path=None):
        """
        Plot ROC curve
        """
        fpr, tpr, thresholds = roc_curve(y_true, y_pred_proba)
        auc_score = roc_auc_score(y_true, y_pred_proba)
        
        plt.figure(figsize=(8, 6))
        plt.plot(fpr, tpr, color='darkorange', lw=2, 
                label=f'ROC curve (AUC = {auc_score:.3f})')
        plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title(f'ROC Curve - {dataset_name}')
        plt.legend(loc="lower right")
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()
        
        return auc_score
    
    def perform_shap_analysis(self, X, save_path=None):
        """
        Perform SHAP analysis for model interpretation
        """
        explainer = shap.TreeExplainer(self.model)
        shap_values = explainer.shap_values(X)
        
        # Summary plot
        plt.figure(figsize=(10, 8))
        shap.summary_plot(shap_values, X, feature_names=self.feature_names, show=False)
        if save_path:
            plt.savefig(f"{save_path}_summary.png", dpi=300, bbox_inches='tight')
        plt.show()
        
        # Force plot for first instance (example)
        plt.figure(figsize=(12, 6))
        shap.force_plot(explainer.expected_value, shap_values[0,:], 
                       X.iloc[0,:], feature_names=self.feature_names, 
                       matplotlib=True, show=False)
        if save_path:
            plt.savefig(f"{save_path}_force_plot.png", dpi=300, bbox_inches='tight')
        plt.show()
        
        return explainer, shap_values
    
    def survival_analysis(self, predictions, pfs_times, pfs_status, cutoff, save_path=None):
        """
        Perform Kaplan-Meier survival analysis
        """
        # Stratify patients into risk groups
        risk_groups = (predictions >= cutoff).astype(int)
        
        # Perform log-rank test
        results = logrank_test(pfs_times[risk_groups == 0], 
                             pfs_times[risk_groups == 1],
                             pfs_status[risk_groups == 0], 
                             pfs_status[risk_groups == 1])
        
        # Plot Kaplan-Meier curves
        plt.figure(figsize=(10, 6))
        
        kmf = KaplanMeierFitter()
        
        # Low risk group
        kmf.fit(pfs_times[risk_groups == 0], pfs_status[risk_groups == 0], 
                label='Low Risk')
        kmf.plot(ci_show=True)
        
        # High risk group  
        kmf.fit(pfs_times[risk_groups == 1], pfs_status[risk_groups == 1],
                label='High Risk')
        kmf.plot(ci_show=True)
        
        plt.xlabel('Time (months)')
        plt.ylabel('PFS Probability')
        plt.title(f'Kaplan-Meier Curves by Risk Group\n(log-rank p-value: {results.p_value:.4f})')
        plt.grid(True)
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()
        
        return results.p_value
